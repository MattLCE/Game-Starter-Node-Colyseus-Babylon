# Game Platform Design

This document describes the technical platform, architecture, and core infrastructure choices for the game project. This platform provides the foundation upon which the specific game logic and features are built.

See also:
*   [`ARCHITECTURE.md`](./ARCHITECTURE.md) (Higher-level overview)
*   [`CONTRIBUTING.md`](./CONTRIBUTING.md) (Development processes)
*   [`DESIGN-GAME.md`](./DESIGN-GAME.md) (Game-specific logic and features)

## 1. Core Technologies

*   **Client Rendering:** **Babylon.js** - Chosen for its powerful WebGL/WebGPU features, performance, maturity, TypeScript support, and extensive documentation for building 3D web experiences.
*   **Server Networking & State Sync:** **Colyseus** - Chosen for its authoritative server model, robust WebSocket handling, efficient schema-based state synchronization, room management, and good TypeScript integration via Node.js. Simplifies multiplayer complexity significantly.
*   **Server Runtime:** **Node.js** - Standard, high-performance JavaScript runtime suitable for Colyseus and TypeScript development. Event-driven model fits well with network communication.
*   **Language:** **TypeScript** - Used for both client and server code to provide static typing, improved code quality, better tooling, and easier refactoring.
*   **Physics (Server-Side - Planned):** **Rapier.js** (`@dimforge/rapier3d-compat`) - Planned for integration on the server for authoritative collision detection and physics simulation. Chosen for its performance (Rust compiled to WASM) and JavaScript bindings.
*   **Build Tools:**
    *   **Vite:** Client-side bundling, development server, fast builds.
    *   **tsc:** Server-side TypeScript compilation.
*   **Testing:** **Vitest** - Chosen for its speed, compatibility with Vite, and Jest-like API for unit testing TypeScript code.
*   **Code Quality:** **ESLint** (linting) & **Prettier** (formatting) - Enforce code standards and consistency.

## 2. Project Structure

A monorepo-like structure managed within a single Git repository:

*   `/` (Root): Contains shared configs (`.replit`, `replit.nix`, `package.json` for root dev deps, `tsconfig.json` base, `vite.config.ts`, `vitest.config.ts`, `eslint.config.mjs`, `.prettierrc.json`, `.gitignore`), documentation (`README.md`, `ARCHITECTURE.md`, `DESIGN-*.md`, `CONTRIBUTING.md`).
*   `/client`: Contains all client-specific code and assets.
    *   `package.json`: Client dependencies (Babylon.js, Colyseus Client SDK).
    *   `tsconfig.json`: Client-specific TS config.
    *   `index.html`: Entry point for the client application.
    *   `style.css`: Global styles for HTML overlays.
    *   `/src`: Client TypeScript source code (`client.ts`, UI components, Babylon logic).
    *   `/public`: Static assets (models, textures, sounds) served directly.
    *   `/dist`: Build output generated by Vite (not committed to Git).
*   `/server`: Contains all server-specific code.
    *   `package.json`: Server dependencies (Colyseus, Express, geotic - planned, rapier - planned).
    *   `tsconfig.json`: Server-specific TS config (targets CommonJS, enables decorators).
    *   `/src`: Server TypeScript source code (`server.ts` entry, `myroom.ts`, state schema, ECS systems, simulation logic).
    *   `/dist`: Build output generated by `tsc` (not committed to Git).
*   `/shared`: (Optional) For TypeScript code/interfaces/types shared between client and server (e.g., shared data structures not part of Colyseus schema).

## 3. Server Architecture

*   **Authoritative:** Server dictates all game state and validates all client actions.
*   **Colyseus Room:** Each active game session runs within a dedicated Colyseus `Room` instance (`MyRoom`).
*   **Simulation Loop:** The core game logic runs within a fixed timestep loop managed by `room.setSimulationInterval()`.
*   **ECS (Planned):** Game logic within the loop will be structured using an Entity Component System pattern (`geotic`). Entities (Player, NPC, Item) possess Components (Position, Velocity, Inventory), and Systems (MovementSystem, CollectionSystem) process entities based on their components.
*   **State Synchronization:** Game state relevant to clients is defined using `@colyseus/schema`. Only changes (deltas) to this state are automatically broadcast to clients by Colyseus.
*   **Physics (Planned):** Rapier.js runs within the server simulation loop for authoritative physics results. Physics results update Components, which in turn update the Colyseus schema state.
*   **API:** Primarily WebSocket communication handled by Colyseus. Minimal HTTP API via Express for health checks or potential future webhooks/admin tasks.

## 4. Client Architecture

*   **Presentation Layer:** Primarily responsible for rendering the game world based on the state received from the server.
*   **Dual UI:**
    *   Babylon.js Canvas: Renders the 3D scene.
    *   HTML Overlay: Standard DOM elements for menus, HUD, etc., layered above the canvas. Managed with vanilla TS/JS.
*   **State Management:**
    *   Receives authoritative state replica via Colyseus SDK (`room.state`).
    *   Listens for changes (`room.onStateChange`, schema callbacks) to update the Babylon scene (moving meshes, playing effects).
    *   Maintains a separate simple UI state machine (`LOADING`, `AT_STATION`, `IN_GAME`, etc.) to control HTML overlays and general client phase.
*   **Input Handling:** Captures raw user input (keyboard, mouse, touch) and sends structured intent messages to the server via `room.send()`. Avoids complex client-side simulation beyond basic cosmetic prediction if implemented later.

## 5. Build & Deployment

*   **Development:** The `.replit` `run` command orchestrates `npm install`, `vite build` (client), `tsc` (server), and `node` (start server). Vite dev server provides HMR for client development if run separately. `tsc-watch` can provide server HMR.
*   **Production (Planned):** Requires a robust hosting platform (Node.js hosting like Render, DigitalOcean App Platform, or Colyseus Arena Cloud). CI/CD pipeline (GitHub Actions) to automate testing, building, and deployment. Static client assets served via CDN (Cloudflare).

## 6. Persistence

*   **MVP:** `localStorage` used *on the client* ONLY for storing data *after* receiving confirmation/state from the server (e.g., total deposited score). Not authoritative, easily lost/edited.
*   **Production (Planned):** Server-side database (PostgreSQL/MongoDB/etc., potentially via BaaS like Supabase/Firebase) connected to the Colyseus server. Player data tied to user accounts (Authentication required). Server is responsible for loading/saving persistent data.